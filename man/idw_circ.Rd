% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/from_rotationR.R
\name{idw_circ}
\alias{idw_circ}
\title{Inverse Distance Weighting with Directional Data}
\usage{
idw_circ(values, coords, grid, idp = 2)
}
\arguments{
\item{values}{azimuth in degree}

\item{coords}{An spatial object of locations where the values were measured.}

\item{grid}{An spatial objector with the locations to predict.}

\item{idp}{inverse distance weighting power}
}
\value{
\code{data.frame} with the grid coordinates, the interpolated
mean values, and the standard deviation for each of the grid
}
\description{
Function for inverse distance weighted interpolation with directional data.
Useful for when you are working with data whose unit of measurement is
degrees (i.e. the average of 35 degrees and 355 degrees should be 15
degrees). It works by finding the shortest distance between two degree marks
on a circle.
}
\examples{
values <- c(55, 355)
coords <- data.frame(lon = c(1, 2), lat = c(1, 2))
sp::coordinates(coords) <- ~lon+lat
sp::proj4string(coords) <- "+proj=longlat +datum=WGS84"

grid <- data.frame(lon = c(1, 2, 1, 2), lat = c(1, 2, 2, 1))
sp::coordinates(grid) <- ~lon+lat
sp::proj4string(grid) <- "+proj=longlat +datum=WGS84"

## Perform the inverse distance weighted interpolation
res <- idw_circ(values, coords, grid)
head(res)
}
